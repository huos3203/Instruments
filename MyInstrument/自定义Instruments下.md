





793
00:26:03,626 --> 00:26:04,886
>> 谢谢你 Chad

794
00:26:09,836 --> 00:26:12,576
《Trailblazer》 App 是一款 iOS App

795
00:26:12,706 --> 00:26:14,676
它可以显示你附近

796
00:26:14,796 --> 00:26:16,176
流行的徒步旅行路线

797
00:26:16,856 --> 00:26:19,976
作为 UI 组件 它使用了 UITabelView

798
00:26:21,006 --> 00:26:22,766
每个单元异步加载

799
00:26:22,766 --> 00:26:24,156
路线的图像

800
00:26:25,276 --> 00:26:26,936
为了防止出现故障且作为优化

801
00:26:26,936 --> 00:26:28,876
当单元被重复使用时

802
00:26:28,876 --> 00:26:30,376
我们取消了下载

803
00:26:31,556 --> 00:26:33,276
为了可视化我的下载流

804
00:26:33,276 --> 00:26:35,546
我将每个下载都置入到

805
00:26:35,586 --> 00:26:36,356
os_signpost 调用中

806
00:26:36,356 --> 00:26:36,936
让我们看一下

807
00:26:41,536 --> 00:26:42,556
当我的保存的单元显示时

808
00:26:42,556 --> 00:26:45,556
调用 startImageDownload() 方法

809
00:26:46,046 --> 00:26:48,456
我们创建了 downloader 和 signpost ID

810
00:26:48,456 --> 00:26:50,946
它包含了 os 日志句柄

811
00:26:51,026 --> 00:26:52,466
和 downloader 对象

812
00:26:53,306 --> 00:26:55,516
然后我们获取 UI 表格视图

813
00:26:55,516 --> 00:26:59,366
单元的地址 

814
00:26:59,366 --> 00:27:03,016
并调用 os_signpost(.begin)

815
00:26:59,366 --> 00:27:03,016
并调用 os_signpost(.begin)

816
00:27:03,016 --> 00:27:04,676
它自于 signpostlog.networking

817
00:27:04,946 --> 00:27:07,336
让我们看一下

818
00:27:07,336 --> 00:27:08,916
这个日志以 App 的

819
00:27:08,916 --> 00:27:11,076
标识符为子系统

820
00:27:11,106 --> 00:27:12,296
networking 为类别

821
00:27:15,046 --> 00:27:16,506
我们传入 “Background Image” 这个名称

822
00:27:17,286 --> 00:27:18,996
之前创建的 “signpostID”

823
00:27:19,436 --> 00:27:20,886
以及信息格式

824
00:27:20,886 --> 00:27:22,016
其中包含 “Image name”

825
00:27:23,956 --> 00:27:25,276
在这里 我们将它放置在全局说明符中

826
00:27:25,276 --> 00:27:27,406
因为它是一个字符串

827
00:27:28,286 --> 00:27:30,406
还有 “Caller” 它是一个单元的地址

828
00:27:31,816 --> 00:27:33,916
我们的下载可以

829
00:27:33,956 --> 00:27:35,476
通过两种方法完成

830
00:27:36,106 --> 00:27:39,086
我们现在来看看

831
00:27:39,166 --> 00:27:40,236
当下载以这样的方式完成

832
00:27:40,756 --> 00:27:42,816
就会调用委托方法

833
00:27:43,866 --> 00:27:45,636
我们像之前一样创建 signpostID

834
00:27:45,636 --> 00:27:48,496
并调用 os_signpost(.end)

835
00:27:49,546 --> 00:27:52,556
这次我们传入 “Status” 和 “Size”

836
00:27:53,876 --> 00:27:56,956
“Status” 值是 “Completed”

837
00:27:58,256 --> 00:28:01,786
“Size” 设置为图像大小

838
00:27:58,256 --> 00:28:01,786
“Size” 设置为图像大小

839
00:28:02,236 --> 00:28:04,456
接下来让我们看一下

840
00:28:04,456 --> 00:28:06,166
我们为重写所做的准备

841
00:28:06,766 --> 00:28:09,546
当 downloader 正在运行时

842
00:28:09,546 --> 00:28:11,116
我们会取消它

843
00:28:12,126 --> 00:28:14,076
我们创建了 signpostID

844
00:28:14,076 --> 00:28:16,006
并使用相同的格式字符串

845
00:28:16,006 --> 00:28:18,016
调用我们的 os_signpost(.end)

846
00:28:18,016 --> 00:28:20,496
但是这里 值是 “Canceled” 并且 “Size”

847
00:28:20,496 --> 00:28:21,896
为 “0” 因为下载没有成功

848
00:28:22,406 --> 00:28:25,446
让我们来看看

849
00:28:25,446 --> 00:28:26,786
我们的 os-signpost-interval-schema 定义

850
00:28:26,786 --> 00:28:28,326
以及我们如何在包中

851
00:28:28,376 --> 00:28:30,386
捕获这些 signpost

852
00:28:32,456 --> 00:28:34,456
我们定义了具有唯一 id 和 title 的

853
00:28:34,456 --> 00:28:36,936
os-signpost-interval-schema

854
00:28:37,686 --> 00:28:40,306
然后我们定义 subsystem 和 category

855
00:28:40,306 --> 00:28:41,856
它与我们在创建

856
00:28:41,856 --> 00:28:43,326
日志句柄时

857
00:28:43,326 --> 00:28:44,596
传递的 category 相对应

858
00:28:46,816 --> 00:28:49,346
我们创建 name 元素

859
00:28:49,346 --> 00:28:50,846
它与我们在 os_signpost 

860
00:28:50,846 --> 00:28:53,646
调用 start-pattern 和 end-pattern 中

861
00:28:54,016 --> 00:28:56,156
传递的 name 相对应

862
00:28:56,736 --> 00:28:58,496
这两个都对应于

863
00:28:58,656 --> 00:29:00,296
我们在 os_signpost 中传入的

864
00:28:58,656 --> 00:29:00,296
我们在 os_signpost 中传入的

865
00:29:00,296 --> 00:29:01,756
开始和结束调用

866
00:29:04,266 --> 00:29:05,966
message 元素与

867
00:29:05,966 --> 00:29:07,596
传递的格式字符串相同

868
00:29:07,596 --> 00:29:10,326
但是在调用 os_signpost 时

869
00:29:10,326 --> 00:29:12,516
为了捕获传入的值

870
00:29:12,516 --> 00:29:14,406
你传递的将是这里的变量

871
00:29:14,406 --> 00:29:15,556
而不是格式化参数

872
00:29:16,066 --> 00:29:18,786
让我们看看如何

873
00:29:18,786 --> 00:29:20,576
在列中填入这些值

874
00:29:23,926 --> 00:29:26,876
在这里 你可以看到 status 列

875
00:29:27,066 --> 00:29:28,566
它是字符串类型

876
00:29:28,566 --> 00:29:30,246
因为它只可能是 “Completed” 或者 “Canceled”

877
00:29:31,486 --> 00:29:32,756
所以我们用状态变量的值

878
00:29:32,756 --> 00:29:34,956
来填充它

879
00:29:36,676 --> 00:29:38,806
因为 expression 元素可以采用

880
00:29:38,926 --> 00:29:40,826
任意的 CLIPS 表达式

881
00:29:41,706 --> 00:29:42,586
所以我们可以在其中

882
00:29:42,586 --> 00:29:44,156
做更复杂的事情

883
00:29:44,816 --> 00:29:47,056
在这里我们可以通过查看图像大小

884
00:29:47,056 --> 00:29:49,006
来计算事件影响

885
00:29:49,846 --> 00:29:51,536
如果它大于 3.5MB

886
00:29:51,536 --> 00:29:53,326
我们可以判定影响很大

887
00:29:53,416 --> 00:29:56,516
否则操作的影响很小

888
00:29:58,076 --> 00:30:00,236
这就是我们对 os-signpost-interval-schema 

889
00:29:58,076 --> 00:30:00,236
这就是我们对 os-signpost-interval-schema 

890
00:30:00,236 --> 00:30:00,976
所做的定义

891
00:30:01,106 --> 00:30:04,066
现在让我们来看看表格的创建

892
00:30:05,796 --> 00:30:07,696
对于 schema-ref

893
00:30:08,096 --> 00:30:10,456
我们传入 os-signpost-interval-schema 

894
00:30:10,456 --> 00:30:12,616
的标识符

895
00:30:12,616 --> 00:30:13,846
并为这个特定表格

896
00:30:13,846 --> 00:30:14,686
创建唯一标识符

897
00:30:15,906 --> 00:30:17,736
然后 我们可以在

898
00:30:17,736 --> 00:30:18,876
UI 定义中引用它

899
00:30:20,296 --> 00:30:22,676
对于 graph 我们创建一个单轨道

900
00:30:23,796 --> 00:30:26,036
它利用我们的表

901
00:30:26,036 --> 00:30:28,056
这次它通过使用 Plot 模板来绘制图形

902
00:30:28,796 --> 00:30:30,586
Plot 模板

903
00:30:30,586 --> 00:30:31,476
是创建图形的动态方法

904
00:30:32,146 --> 00:30:37,386
它查看在实例中

905
00:30:37,386 --> 00:30:40,126
按元素传递的列

906
00:30:40,226 --> 00:30:44,436
并为该列的每个唯一值创建 Plot

907
00:30:44,606 --> 00:30:46,436
label-format 元素

908
00:30:46,486 --> 00:30:49,966
允许我们为这个 Plot 创建格式标题

909
00:30:50,336 --> 00:30:53,956
这里是 img 列和 image-name 列中的值

910
00:30:54,516 --> 00:30:57,166
我们传入 image-name

911
00:30:57,166 --> 00:30:57,656
作为我们的 Plot 的值

912
00:30:58,766 --> 00:31:00,156
我们的每个轨道

913
00:30:58,766 --> 00:31:00,156
我们的每个轨道

914
00:31:00,206 --> 00:31:03,166
都会以 impact 列上色

915
00:31:03,326 --> 00:31:06,076
我们轨道上的标签

916
00:31:06,076 --> 00:31:06,976
会从 image-size 中提取出来

917
00:31:09,436 --> 00:31:12,796
接下来 我们看看 list

918
00:31:12,796 --> 00:31:14,726
你已经在 Ticks 的例子中

919
00:31:14,756 --> 00:31:15,526
见过它

920
00:31:16,866 --> 00:31:18,176
这里 我们将传入

921
00:31:18,176 --> 00:31:21,286
你希望看到的所有列

922
00:31:21,536 --> 00:31:22,766
接下来是 aggregation

923
00:31:23,726 --> 00:31:25,266
这个 aggregation 将跟踪

924
00:31:25,266 --> 00:31:26,406
所有已完成的下载

925
00:31:27,236 --> 00:31:29,836
因为我们的表

926
00:31:29,836 --> 00:31:31,146
包含已完成和已取消的下载

927
00:31:31,146 --> 00:31:32,406
所以我们需要应用

928
00:31:32,406 --> 00:31:34,836
slice 元素来过滤一些数据

929
00:31:36,016 --> 00:31:37,866
在 slice 元素中

930
00:31:37,866 --> 00:31:39,456
我们可以指定

931
00:31:39,456 --> 00:31:42,066
应用于 slice 的列

932
00:31:42,596 --> 00:31:43,496
以及需要匹配的谓词值

933
00:31:43,926 --> 00:31:45,546
在这里 我们只想从这个表中

934
00:31:45,546 --> 00:31:47,056
取出 “Completed” 的行

935
00:31:48,306 --> 00:31:50,746
我们定义了 hierarchy

936
00:31:50,746 --> 00:31:52,406
它是只有一个层级的结构

937
00:31:52,486 --> 00:31:55,276
具有 image-name

938
00:31:55,276 --> 00:31:55,836
和可见的列

939
00:31:56,676 --> 00:31:58,786
对于每个 image-name

940
00:31:58,786 --> 00:32:02,156
我们将指定 count 和 image-size

941
00:31:58,786 --> 00:32:02,156
我们将指定 count 和 image-size

942
00:32:02,156 --> 00:32:04,916
所以我们要将图像的大小求和

943
00:32:05,386 --> 00:32:09,426
接下来我们有 time-slice

944
00:32:10,456 --> 00:32:10,746
抱歉

945
00:32:10,746 --> 00:32:12,186
我们指定所有

946
00:32:12,186 --> 00:32:13,046
将会可见的列

947
00:32:16,096 --> 00:32:18,636
为了更容易地使用我们的 Instrument

948
00:32:18,636 --> 00:32:22,796
我们可以指定我们的

949
00:32:22,796 --> 00:32:23,566
自定义模板

950
00:32:24,126 --> 00:32:26,876
我们现在尝试构建和运行

951
00:32:26,986 --> 00:32:27,306
我们的包

952
00:32:34,416 --> 00:32:36,336
你可以看到这里的模板

953
00:32:36,396 --> 00:32:36,976
我可以选中它

954
00:32:41,536 --> 00:32:43,916
Target 是我的 iPhone

955
00:32:43,916 --> 00:32:45,186
和《Trailblazer》App

956
00:32:48,956 --> 00:32:50,976
我需要记录一会

957
00:33:00,716 --> 00:33:03,786
可以看到

958
00:33:03,786 --> 00:33:04,936
跟踪视图是以数据传递的

959
00:33:06,616 --> 00:33:08,746
每一个图像名称都创建了

960
00:33:08,746 --> 00:33:09,636
一个绘图

961
00:33:11,366 --> 00:33:12,816
你可以看到标签格式

962
00:33:12,816 --> 00:33:14,366
与我们在包定义中

963
00:33:14,366 --> 00:33:15,586
传入的格式相匹配

964
00:33:16,596 --> 00:33:19,056
如果下载

965
00:33:19,056 --> 00:33:21,176
高于 3.5 MB

966
00:33:21,176 --> 00:33:22,406
那么我们的轨道将是红色的

967
00:33:23,596 --> 00:33:25,266
具体的大小可以在轨道上查看

968
00:33:25,786 --> 00:33:28,576
接下来我们看看

969
00:33:28,576 --> 00:33:30,286
所有的细节

970
00:33:32,436 --> 00:33:35,146
首先 我们看一下下载列表

971
00:33:36,066 --> 00:33:38,096
这是刚才发生的

972
00:33:38,096 --> 00:33:38,976
所有下载的列表

973
00:33:39,636 --> 00:33:42,346
我们可以选择聚合

974
00:33:42,866 --> 00:33:46,746
按照图像名称

975
00:33:46,746 --> 00:33:48,236
划分所有下载

976
00:33:48,616 --> 00:33:49,926
你可以在上面看到

977
00:33:49,926 --> 00:33:51,856
我们下载了 12 张图像

978
00:33:52,156 --> 00:33:55,886
“location7” 的图像

979
00:33:55,886 --> 00:33:59,436
被下载了两次

980
00:33:59,616 --> 00:34:00,876
接下来

981
00:33:59,616 --> 00:34:00,876
接下来

982
00:34:00,876 --> 00:34:02,676
我们可以查看活动请求

983
00:34:03,296 --> 00:34:05,166
你可以在这里看到

984
00:34:05,166 --> 00:34:07,386
当我拖动我的检查线时

985
00:34:09,356 --> 00:34:12,786
细节视图中的数据发生了变化

986
00:34:13,646 --> 00:34:15,835
我们可以跟踪

987
00:34:15,876 --> 00:34:17,505
多个活动请求

988
00:34:17,505 --> 00:34:19,106
并查看截至当前检查线为止的

989
00:34:19,106 --> 00:34:20,426
持续时间

990
00:34:21,896 --> 00:34:23,976
如果你想从不同的角度

991
00:34:23,976 --> 00:34:25,286
查看你的数据

992
00:34:25,536 --> 00:34:28,226
并想查看你的存储和建模器

993
00:34:28,226 --> 00:34:31,056
我们通过 Instrument 检查器

994
00:34:31,056 --> 00:34:32,606
为你提供了这个功能

995
00:34:33,576 --> 00:34:34,976
它是调试自定义 Instrument 的

996
00:34:34,976 --> 00:34:36,076
一种方法

997
00:34:36,716 --> 00:34:38,396
在这里你可以看到

998
00:34:38,396 --> 00:34:41,646
我选择了存储步骤

999
00:34:41,976 --> 00:34:43,876
并看到创建 os-signpost 的存储

1000
00:34:44,556 --> 00:34:46,916
它属于网络类别

1001
00:34:47,335 --> 00:34:48,956
和 com.apple.trailblazer 子系统

1002
00:34:48,956 --> 00:34:52,216
我们在这里收集了 24 行

1003
00:34:53,235 --> 00:34:55,376
然后我们可以看到

1004
00:34:55,466 --> 00:34:57,216
创建的表格 image-download

1005
00:34:57,366 --> 00:34:57,896
它有 12 行

1006
00:35:02,156 --> 00:35:04,326
在底部的区域

1007
00:35:04,326 --> 00:35:04,976
你可以看到该表的整个内容

1008
00:35:07,396 --> 00:35:09,146
接下来 我们跳转到建模器

1009
00:35:09,546 --> 00:35:10,706
我们可以看到这里有

1010
00:35:10,806 --> 00:35:12,936
GENERATED-OS-LOG 建模器

1011
00:35:13,456 --> 00:35:16,916
它使用了 24 行 输出了 12 行

1012
00:35:18,346 --> 00:35:20,756
在右边 你可以看到绑定方案

1013
00:35:21,546 --> 00:35:23,826
所以我们的 GENERATED-OS-LOG 建模器

1014
00:35:24,206 --> 00:35:26,026
从 os-signpost 表格中获取数据

1015
00:35:26,026 --> 00:35:28,216
并将其放入图像下载表格中

1016
00:35:29,386 --> 00:35:31,886
然后被我们的 Instrument 使用

1017
00:35:32,446 --> 00:35:35,766
我们就是这样

1018
00:35:35,766 --> 00:35:37,966
捕获 os-signpost 调用

1019
00:35:38,036 --> 00:35:40,366
创建 UI 并使用 Instrument 检查器

1020
00:35:40,366 --> 00:35:41,376
查看数据

1021
00:35:42,036 --> 00:35:43,866
现在让我们请回 Chad

1022
00:35:43,916 --> 00:35:44,846
他会告诉你们更多

1023
00:35:44,846 --> 00:35:45,836
关于进阶建模的内容

1024
00:35:46,516 --> 00:35:50,500
[ 掌声 ]

1025
00:35:54,716 --> 00:35:55,056
>> 好的

1026
00:35:55,326 --> 00:35:56,006
谢谢 Kacper

1027
00:35:57,646 --> 00:35:59,366
现在我们已经了解了

1028
00:35:59,366 --> 00:36:01,686
如何将 os-signpost 数据

1029
00:35:59,366 --> 00:36:01,686
如何将 os-signpost 数据

1030
00:36:01,746 --> 00:36:03,396
与自定义 Instrument 结合起来

1031
00:36:03,776 --> 00:36:10,106
我们认为你们 能把这个结合做得很好

1032
00:36:10,886 --> 00:36:13,846
现在 我们可以讨论一些

1033
00:36:13,846 --> 00:36:15,026
进阶的内容

1034
00:36:15,056 --> 00:36:16,546
特别是如何创建

1035
00:36:16,546 --> 00:36:18,286
和定义建模器

1036
00:36:19,366 --> 00:36:20,466
建模器在概念上是

1037
00:36:20,466 --> 00:36:21,296
非常简单的机器

1038
00:36:21,296 --> 00:36:23,156
它需要一系列的输入

1039
00:36:23,266 --> 00:36:24,256
它对这些输入做出推理

1040
00:36:24,256 --> 00:36:26,376
然后进行输出

1041
00:36:27,326 --> 00:36:28,506
建模器的输入

1042
00:36:28,506 --> 00:36:30,246
是完全按照时间排序的

1043
00:36:30,736 --> 00:36:32,116
因此如果你请求

1044
00:36:32,116 --> 00:36:33,506
几个不同的输入表

1045
00:36:33,506 --> 00:36:34,756
这些表将首先按时间排序

1046
00:36:34,756 --> 00:36:36,246
然后合并到一个

1047
00:36:36,246 --> 00:36:38,646
按时间排序的队列中

1048
00:36:38,646 --> 00:36:39,406
该队列将提供工作内存

1049
00:36:39,916 --> 00:36:41,356
当我们把这些事件

1050
00:36:41,356 --> 00:36:42,476
一个接一个地取出时

1051
00:36:42,536 --> 00:36:43,776
它们被输入到所谓的

1052
00:36:43,776 --> 00:36:44,356
建模器的工作内存中

1053
00:36:45,236 --> 00:36:47,886
当建模器看到

1054
00:36:47,886 --> 00:36:49,306
这个工作内存的增长时

1055
00:36:49,306 --> 00:36:51,006
它就可以得出推论

1056
00:36:51,226 --> 00:36:52,766
当建模器看到需要为其

1057
00:36:52,766 --> 00:36:54,086
进行输出的模板时

1058
00:36:54,086 --> 00:36:56,206
它只需将其

1059
00:36:56,206 --> 00:36:57,406
写入对外输出表格

1060
00:36:58,166 --> 00:37:00,256
让我们以一个

1061
00:36:58,166 --> 00:37:00,256
让我们以一个

1062
00:37:00,406 --> 00:37:01,766
非常有趣的例子

1063
00:37:01,766 --> 00:37:03,336
来介绍如何使用建模器

1064
00:37:03,606 --> 00:37:05,966
假设你定义了一个 Schema

1065
00:37:06,106 --> 00:37:07,906
叫做 playing-with-matches

1066
00:37:08,006 --> 00:37:10,166
它是一个

1067
00:37:10,166 --> 00:37:12,666
os-signpost-interval-schema

1068
00:37:12,876 --> 00:37:14,156
可以使已经定义的 os_signpost

1069
00:37:14,156 --> 00:37:15,036
在你的代码中

1070
00:37:15,036 --> 00:37:17,226
做一些危险的操作

1071
00:37:17,726 --> 00:37:19,996
我们又定义了另一个 Schema

1072
00:37:20,156 --> 00:37:21,766
叫做 app-on-fire

1073
00:37:22,186 --> 00:37:23,916
它也是一个 signpost Schema

1074
00:37:24,066 --> 00:37:25,206
但是这些 signpost 意味着

1075
00:37:25,206 --> 00:37:27,386
App 进入了一个糟糕的状态

1076
00:37:27,386 --> 00:37:29,396
我们真的很想知道原因

1077
00:37:30,406 --> 00:37:31,816
还要创建一个输出 Schema

1078
00:37:31,816 --> 00:37:33,306
它是一个 point-schema

1079
00:37:33,306 --> 00:37:35,836
它会保存 playing-with-matches 的对象

1080
00:37:35,836 --> 00:37:37,476
以及对象“起火”的时间

1081
00:37:37,956 --> 00:37:38,676
我们打算将它

1082
00:37:38,676 --> 00:37:39,796
命名为 started-a-fire

1083
00:37:39,796 --> 00:37:44,066
建模器看起来是这样的

1084
00:37:44,226 --> 00:37:46,686
所有的输入

1085
00:37:46,686 --> 00:37:48,486
都按时间顺序设置好了

1086
00:37:48,486 --> 00:37:51,096
左边的虚线就是

1087
00:37:51,096 --> 00:37:53,126
所谓的建模器时钟

1088
00:37:54,136 --> 00:37:55,976
当我们获取第一个输入

1089
00:37:55,976 --> 00:37:57,206
将其置入到工作内存中时

1090
00:37:57,206 --> 00:37:58,636
建模器时钟

1091
00:37:58,686 --> 00:37:59,686
将移动到区间的起始处

1092
00:37:59,686 --> 00:38:03,076
然后我们获取下一个输入

1093
00:37:59,686 --> 00:38:03,076
然后我们获取下一个输入

1094
00:38:03,076 --> 00:38:04,666
建模器时钟

1095
00:38:04,666 --> 00:38:06,036
再次移动到区间的起始处

1096
00:38:06,036 --> 00:38:08,046
我们将其置入到工作内存中

1097
00:38:08,836 --> 00:38:10,376
建模器观察

1098
00:38:10,376 --> 00:38:12,656
工作内存的这两个区间

1099
00:38:12,656 --> 00:38:14,366
建模器可以观察

1100
00:38:14,366 --> 00:38:16,256
playing-with-matches 是否在

1101
00:38:16,256 --> 00:38:17,336
app-on-fire 之前开始

1102
00:38:17,336 --> 00:38:18,886
这其实没有多大区别

1103
00:38:19,176 --> 00:38:19,956
如果反过来

1104
00:38:19,956 --> 00:38:22,406
app-on-fire 也已经开始了

1105
00:38:22,406 --> 00:38:24,086
我们就可以得出一个合乎逻辑的结论

1106
00:38:25,396 --> 00:38:27,936
叫做 cause-of-fire 

1107
00:38:27,936 --> 00:38:29,846
并将它置入工作内存中

1108
00:38:31,676 --> 00:38:33,456
当我们获取第三个输入时

1109
00:38:33,756 --> 00:38:34,986
你会注意到

1110
00:38:34,986 --> 00:38:36,636
建模器时钟已经移动

1111
00:38:36,636 --> 00:38:38,996
它不再与前两个输入相交

1112
00:38:39,516 --> 00:38:41,956
所以它们将被从工作内存中移除

1113
00:38:42,766 --> 00:38:44,636
如果 cause-of-fire 有

1114
00:38:44,636 --> 00:38:45,886
所谓的逻辑支持

1115
00:38:46,326 --> 00:38:50,556
它也会被从内存中移除

1116
00:38:50,856 --> 00:38:52,926
回顾一下 时钟总是被设置为

1117
00:38:52,926 --> 00:38:54,926
当前输入的时间戳

1118
00:38:55,556 --> 00:38:57,576
对于留在工作内存中的

1119
00:38:57,576 --> 00:38:58,936
输入而言

1120
00:38:58,936 --> 00:39:01,836
它必须与建模器中的

1121
00:38:58,936 --> 00:39:01,836
它必须与建模器中的

1122
00:39:01,836 --> 00:39:02,406
当前时钟相交

1123
00:39:02,956 --> 00:39:04,876
这可以帮助我们建立重合

1124
00:39:04,876 --> 00:39:06,606
它能让我们删除旧数据

1125
00:39:06,606 --> 00:39:08,626
也能让我们了解

1126
00:39:08,666 --> 00:39:10,186
是否存在

1127
00:39:10,186 --> 00:39:13,386
可能与时间相关的输入

1128
00:39:13,916 --> 00:39:15,026
建模器对其

1129
00:39:15,156 --> 00:39:16,766
工作内存的解释

1130
00:39:17,066 --> 00:39:19,196
是通过所谓的 “Production System”

1131
00:39:19,196 --> 00:39:20,426
来定义的

1132
00:39:21,496 --> 00:39:23,466
生产系统处理

1133
00:39:23,466 --> 00:39:25,306
工作内存中的 “Facts（事实）”

1134
00:39:25,306 --> 00:39:26,486
它们由具有左手边 (LHS)

1135
00:39:26,486 --> 00:39:28,176
一个生产操作符

1136
00:39:28,176 --> 00:39:30,346
和右手边 (RHS) 的规则定义

1137
00:39:31,106 --> 00:39:32,896
LHS 是工作内存

1138
00:39:33,306 --> 00:39:35,106
中的一种模板

1139
00:39:35,106 --> 00:39:37,336
它能够激活规则

1140
00:39:37,336 --> 00:39:38,976
而 RHS 则是规则触发时

1141
00:39:38,976 --> 00:39:41,576
发生的动作

1142
00:39:42,036 --> 00:39:43,306
这些操作可以包括

1143
00:39:43,746 --> 00:39:45,686
向输出表中添加一行

1144
00:39:45,866 --> 00:39:48,476
或者在建模过程进行时

1145
00:39:48,526 --> 00:39:50,896
将一个新的事实

1146
00:39:50,896 --> 00:39:52,566
添加到工作内存中

1147
00:39:54,186 --> 00:39:56,826
事实有两个来源

1148
00:39:56,926 --> 00:39:58,046
首先 它们可以来自

1149
00:39:58,046 --> 00:39:59,566
你看到过的表格输入

1150
00:39:59,566 --> 00:40:01,206
通过使用我在建模时钟中

1151
00:39:59,566 --> 00:40:01,206
通过使用我在建模时钟中

1152
00:40:01,206 --> 00:40:03,336
展示的规则

1153
00:40:03,336 --> 00:40:04,246
表输入将被判定为事实

1154
00:40:04,246 --> 00:40:06,376
事实也可以通过

1155
00:40:06,376 --> 00:40:07,846
来自生产的 RHS 的

1156
00:40:07,846 --> 00:40:09,866
判定生成

1157
00:40:11,066 --> 00:40:12,196
如果你要创建你自己的事实

1158
00:40:12,196 --> 00:40:14,336
CLIPS 允许你

1159
00:40:14,336 --> 00:40:15,316
找到所谓的“事实模板”

1160
00:40:15,426 --> 00:40:16,106
你可以为你的事实

1161
00:40:16,106 --> 00:40:17,196
提供结构

1162
00:40:17,196 --> 00:40:17,976
并做一些基本的类型检查

1163
00:40:18,046 --> 00:40:21,306
让我们来看看 CLIPS 中的

1164
00:40:21,306 --> 00:40:22,356
一些规则

1165
00:40:23,226 --> 00:40:24,326
我们要讲的第一个规则

1166
00:40:24,326 --> 00:40:25,926
叫做 found-cause

1167
00:40:27,306 --> 00:40:30,446
它指的是 如果有一个对象

1168
00:40:30,446 --> 00:40:31,806
它的 playing-with-matches

1169
00:40:31,806 --> 00:40:35,526
在 t1 时开始

1170
00:40:35,526 --> 00:40:38,996
app-on-fire 在 t2 时开始

1171
00:40:39,286 --> 00:40:41,466
且 t1 比 t2 提前

1172
00:40:41,466 --> 00:40:42,236
那么在这个生产的 RHS 中

1173
00:40:42,236 --> 00:40:43,756
我们可以判定一个新的事实

1174
00:40:43,756 --> 00:40:46,026
叫做 cause-of-fire 

1175
00:40:46,076 --> 00:40:47,616
以及导致“起火”的对象

1176
00:40:48,196 --> 00:40:49,336
它将进入到

1177
00:40:49,426 --> 00:40:50,096
工作内存中

1178
00:40:51,136 --> 00:40:53,156
我们接下来讨论第二个规则

1179
00:40:53,156 --> 00:40:54,666
也就是 record-cause

1180
00:40:54,666 --> 00:40:58,296
如果我们有一个 App

1181
00:40:58,296 --> 00:41:00,166
在某个开始时间“起火”

1182
00:40:58,296 --> 00:41:00,166
在某个开始时间“起火”

1183
00:41:00,166 --> 00:41:01,796
并且我们知道“起火”的原因

1184
00:41:01,796 --> 00:41:03,536
我们有一个绑定到

1185
00:41:03,536 --> 00:41:05,876
side append 的表格

1186
00:41:05,876 --> 00:41:08,876
它是建模器的输出端

1187
00:41:08,946 --> 00:41:11,336
而且这个表是我们定义的

1188
00:41:11,336 --> 00:41:12,926
叫做 started-a-fire 的 Schema

1189
00:41:12,926 --> 00:41:16,776
我们可以创建一个表格的行

1190
00:41:16,776 --> 00:41:18,126
然后设置时间

1191
00:41:18,246 --> 00:41:19,946
以及导致

1192
00:41:19,946 --> 00:41:21,276
模板中所得的值

1193
00:41:21,276 --> 00:41:23,826
“起火”的 Schema

1194
00:41:23,906 --> 00:41:25,826
通过这两个规则

1195
00:41:25,826 --> 00:41:27,756
我们基本上创建了

1196
00:41:27,756 --> 00:41:29,356
第一个专家系统来查找

1197
00:41:29,356 --> 00:41:31,406
App 中的不良模式

1198
00:41:32,436 --> 00:41:34,376
现在你可能已经注意到

1199
00:41:34,376 --> 00:41:36,016
规则是由 MODELER::

1200
00:41:36,016 --> 00:41:38,396
或 RECORDER:: 预先编写的

1201
00:41:38,966 --> 00:41:39,546
这些都是 CLIPS 中的模块

1202
00:41:39,546 --> 00:41:41,606
它们允许你

1203
00:41:41,606 --> 00:41:43,916
同时把规则分组

1204
00:41:43,916 --> 00:41:45,956
并控制规则的执行顺序

1205
00:41:46,526 --> 00:41:48,556
举个例子

1206
00:41:48,556 --> 00:41:50,946
如果你保持了所有的

1207
00:41:50,946 --> 00:41:52,176
为 RECORDER:: 模块中的输出表格

1208
00:41:52,176 --> 00:41:54,006
生产输出的规则

1209
00:41:55,116 --> 00:41:57,536
你就可以确保

1210
00:41:57,536 --> 00:41:59,896
你不会在建模器的

1211
00:41:59,896 --> 00:42:01,916
推理过程中进行输出

1212
00:41:59,896 --> 00:42:01,916
推理过程中进行输出

1213
00:42:02,246 --> 00:42:03,566
因为在 MODELER:: 中的所有规则 

1214
00:42:03,566 --> 00:42:05,246
必须在 

1215
00:42:05,246 --> 00:42:06,966
RECORDER:: 中的规则

1216
00:42:06,966 --> 00:42:07,746
执行之前执行

1217
00:42:08,686 --> 00:42:10,736
我之前提到过的

1218
00:42:10,736 --> 00:42:12,296
逻辑支持

1219
00:42:12,776 --> 00:42:14,556
逻辑支持通常与

1220
00:42:14,776 --> 00:42:17,066
所谓的对等推理规则

1221
00:42:17,066 --> 00:42:18,586
联系在一起

1222
00:42:18,586 --> 00:42:20,336
这些规则就是 比如说

1223
00:42:20,336 --> 00:42:21,736
如果 A 和 B 那么 C

1224
00:42:22,156 --> 00:42:23,756
向生产中

1225
00:42:23,756 --> 00:42:25,286
添加逻辑支持

1226
00:42:25,286 --> 00:42:29,646
意思就是

1227
00:42:29,646 --> 00:42:30,786
如果 A 和 B 不再

1228
00:42:30,786 --> 00:42:32,126
处于工作内存中

1229
00:42:32,126 --> 00:42:33,606
那么 C 应该被自动收回

1230
00:42:33,656 --> 00:42:35,726
所以我们说

1231
00:42:35,726 --> 00:42:37,016
C 受 A 和 B 的存在的

1232
00:42:37,016 --> 00:42:38,326
逻辑支持

1233
00:42:38,806 --> 00:42:40,346
这很重要

1234
00:42:40,346 --> 00:42:41,606
因为它限制了工作内存膨胀

1235
00:42:41,606 --> 00:42:43,156
这有助于资源消耗

1236
00:42:43,156 --> 00:42:44,436
但从工作内存中

1237
00:42:44,436 --> 00:42:46,096
删除不再有效的事实

1238
00:42:46,096 --> 00:42:48,076
同样也很重要

1239
00:42:48,326 --> 00:42:49,486
如果 A 和 B 不再有效

1240
00:42:49,486 --> 00:42:51,526
那么你应该移除 C

1241
00:42:52,076 --> 00:42:54,596
为了向你的生产

1242
00:42:54,826 --> 00:42:57,606
添加逻辑支持 这里是相关的规则

1243
00:42:57,906 --> 00:42:59,826
你只需将关键字 logical

1244
00:42:59,866 --> 00:43:01,226
填入模板

1245
00:42:59,866 --> 00:43:01,226
填入模板

1246
00:43:01,226 --> 00:43:02,146
那么在向前移动的过程中

1247
00:43:02,146 --> 00:43:03,866
规则中的 RHS

1248
00:43:03,866 --> 00:43:05,986
所判定的任何内容

1249
00:43:05,986 --> 00:43:06,836
都将被自动收回

1250
00:43:07,056 --> 00:43:08,566
你们应该注意到了

1251
00:43:08,816 --> 00:43:10,566
来自我们的 Schema 的

1252
00:43:11,146 --> 00:43:12,876
这两个规则 抱歉

1253
00:43:12,876 --> 00:43:14,326
这两个事实

1254
00:43:14,766 --> 00:43:16,446
它们都是输入

1255
00:43:16,446 --> 00:43:17,176
所以当建模器时钟

1256
00:43:17,176 --> 00:43:18,456
向前移动时

1257
00:43:18,456 --> 00:43:19,636
这些将自动被收回

1258
00:43:22,196 --> 00:43:23,626
好的 现在我们已经了解了

1259
00:43:23,626 --> 00:43:25,476
如何在包中创建

1260
00:43:25,476 --> 00:43:27,336
建模器的基本内容

1261
00:43:27,436 --> 00:43:29,746
并且看到了一些 CLIPS 语言和规则

1262
00:43:30,186 --> 00:43:32,096
让我们来看看

1263
00:43:32,096 --> 00:43:34,626
是否可以在我们的网络 Instrument 中

1264
00:43:34,626 --> 00:43:37,646
添加一个专家系统

1265
00:43:37,646 --> 00:43:39,216
以查找我们的网络层中的

1266
00:43:39,426 --> 00:43:41,106
不良模式和潜在的误用

1267
00:43:41,706 --> 00:43:43,286
为此 让我们邀请 Kacper 上台

1268
00:43:43,286 --> 00:43:44,886
做最后一个演示

1269
00:43:45,516 --> 00:43:50,500
[ 掌声 ]

1270
00:43:55,016 --> 00:43:56,486
>> 有了现有的日志记录

1271
00:43:56,526 --> 00:43:58,176
我将尝试编写建模器

1272
00:43:58,246 --> 00:43:59,796
来检测 App 的

1273
00:43:59,796 --> 00:44:00,956
网络行为中的

1274
00:43:59,796 --> 00:44:00,956
网络行为中的

1275
00:44:00,956 --> 00:44:01,976
一些反面模式

1276
00:44:02,756 --> 00:44:03,656
我在运行我的

1277
00:44:03,656 --> 00:44:05,646
《Trailblazer》 App

1278
00:44:05,646 --> 00:44:07,086
如果我滚动得很快

1279
00:44:07,136 --> 00:44:08,746
这里就会出现

1280
00:44:08,746 --> 00:44:09,476
一些小故障

1281
00:44:09,906 --> 00:44:11,886
图像被多次替换

1282
00:44:11,886 --> 00:44:14,516
所以我怀疑我们的取消

1283
00:44:14,516 --> 00:44:15,906
并没有真正起作用

1284
00:44:17,366 --> 00:44:19,736
我想编写建模器来检测它

1285
00:44:21,186 --> 00:44:23,746
让我们来看看

1286
00:44:23,746 --> 00:44:24,736
我们的包定义

1287
00:44:25,246 --> 00:44:27,916
我们将从编写 modeler 元素开始

1288
00:44:28,636 --> 00:44:31,336
modeler 有 id title

1289
00:44:31,336 --> 00:44:32,366
和 purpose 几个栏

1290
00:44:33,336 --> 00:44:35,316
这些栏将被

1291
00:44:35,316 --> 00:44:36,406
提取到文档中

1292
00:44:37,536 --> 00:44:39,366
我们为 modeler 指定了

1293
00:44:39,366 --> 00:44:41,576
包含所有逻辑的

1294
00:44:41,576 --> 00:44:42,756
production system 的 path

1295
00:44:45,086 --> 00:44:47,466
然后 我们定义了 modeler 的 output

1296
00:44:48,086 --> 00:44:50,006
它将是一个 downloader-narrative Schema

1297
00:44:50,916 --> 00:44:53,506
我们的建模器的 required-input 

1298
00:44:53,506 --> 00:44:55,646
将是 os-signpost 表格

1299
00:44:56,556 --> 00:44:58,836
这个表包含开始

1300
00:44:58,836 --> 00:44:59,686
和结束事件

1301
00:45:00,926 --> 00:45:02,076
现在让我们看一下

1302
00:45:02,526 --> 00:45:03,816
downloader-narrative

1303
00:45:03,816 --> 00:45:04,946
Schema 的定义

1304
00:45:10,896 --> 00:45:13,006
它是一个 point-schema

1305
00:45:13,046 --> 00:45:15,026
定义了两个列

1306
00:45:15,526 --> 00:45:17,216
timestamp

1307
00:45:17,216 --> 00:45:19,046
跟踪记录诊断消息的时间

1308
00:45:20,176 --> 00:45:22,156
description 含有

1309
00:45:22,156 --> 00:45:23,666
运行错误的信息

1310
00:45:26,116 --> 00:45:28,346
然后 我们可以在 Instrument 定义中

1311
00:45:28,676 --> 00:45:30,086
创建这个表

1312
00:45:30,656 --> 00:45:33,316
我们传入 downloader-narrative 的

1313
00:45:33,316 --> 00:45:36,206
schema-ref 和唯一的 id 

1314
00:45:37,896 --> 00:45:40,006
然后我们可以在

1315
00:45:40,136 --> 00:45:42,206
narrative 元素定义中使用它

1316
00:45:44,556 --> 00:45:46,266
在这里我们定义 narrative 

1317
00:45:46,686 --> 00:45:49,006
我们为之前创建的表格

1318
00:45:49,006 --> 00:45:51,466
传入 table-ref

1319
00:45:51,546 --> 00:45:53,766
定义 time-column

1320
00:45:55,616 --> 00:45:55,846
和 narrative-column

1321
00:45:55,936 --> 00:45:57,876
我们已经准备好

1322
00:45:57,876 --> 00:45:58,756
为我们的建模器定义逻辑

1323
00:46:00,256 --> 00:46:01,826
为此 我将创建

1324
00:46:01,826 --> 00:46:03,736
之前在 modeler 定义中

1325
00:46:03,736 --> 00:46:04,766
引用的文件

1326
00:46:05,566 --> 00:46:07,256
为了创建 CLIPS 文件

1327
00:46:07,256 --> 00:46:12,796
前往 “File（文件）”-“New（新建）”

1328
00:46:14,276 --> 00:46:15,786
选择 “macOS” 作为平台 “Other（其他）”部分的

1329
00:46:15,786 --> 00:46:16,366
“CLIPS File（CLIPS 文件）”

1330
00:46:19,196 --> 00:46:27,586
我把名称填好并创建

1331
00:46:27,966 --> 00:46:30,286
下面展示的将是

1332
00:46:30,286 --> 00:46:31,936
检测一个单元

1333
00:46:31,936 --> 00:46:33,486
是否同时执行

1334
00:46:33,486 --> 00:46:34,256
多个请求的算法

1335
00:46:35,046 --> 00:46:37,036
我们将在工作内存中

1336
00:46:37,036 --> 00:46:38,756
追踪每一个作为事实的请求

1337
00:46:39,196 --> 00:46:40,856
首先 我们需要

1338
00:46:41,046 --> 00:46:42,946
为这个事实创建模板

1339
00:46:44,376 --> 00:46:47,696
每个事实都会有

1340
00:46:47,786 --> 00:46:49,996
存储 time

1341
00:46:49,996 --> 00:46:53,236
caller-address 也就是单元地址

1342
00:46:53,236 --> 00:46:56,286
我们捕获到的 signpost-id

1343
00:46:56,286 --> 00:46:57,286
以及我们请求的 image-name

1344
00:46:57,806 --> 00:46:59,796
我们将这个事实叫做 started-download

1345
00:47:01,036 --> 00:47:03,296
然后编写

1346
00:47:03,296 --> 00:47:05,816
在工作内存中 创建此事件的建模器规则

1347
00:47:08,576 --> 00:47:11,676
这个规则查看 os-signpost 表格

1348
00:47:12,536 --> 00:47:15,336
我们指定 subsystem name

1349
00:47:15,426 --> 00:47:18,006
并把 “Begin” 作为 even-type 的值

1350
00:47:18,006 --> 00:47:20,306
并捕获我们想要的所有信息

1351
00:47:21,186 --> 00:47:22,926
我们需要捕获 ?image-name

1352
00:47:22,926 --> 00:47:25,586
?caller-address time 以及 ?identifier

1353
00:47:25,586 --> 00:47:28,956
然后 我们向工作内存判定新的事实

1354
00:47:34,056 --> 00:47:36,676
要在下载完成后清理它

1355
00:47:36,746 --> 00:47:39,406
我们需要从工作内存中

1356
00:47:39,406 --> 00:47:40,666
收回这一事实

1357
00:47:44,426 --> 00:47:46,066
这里我们查看的是同一个表格

1358
00:47:46,066 --> 00:47:48,606
但是我们只查看

1359
00:47:48,866 --> 00:47:51,736
event-type “End”

1360
00:47:52,866 --> 00:47:54,836
我们捕获 signpost 的 identifier

1361
00:47:55,756 --> 00:47:57,426
在这里我们使用的事实

1362
00:47:57,846 --> 00:48:00,096
signpost “Begin” 和 “End”

1363
00:47:57,846 --> 00:48:00,096
signpost “Begin” 和 “End”

1364
00:48:00,136 --> 00:48:01,526
必须有相同的标识符

1365
00:48:02,706 --> 00:48:04,336
我们在工作内存中

1366
00:48:04,566 --> 00:48:07,296
寻找一个具有我们捕获到的

1367
00:48:07,296 --> 00:48:09,726
signpost identifier 的事实

1368
00:48:09,726 --> 00:48:11,346
并收回这个事实

1369
00:48:14,116 --> 00:48:16,286
然后我们可以编写 RECORDER:: 规则

1370
00:48:16,286 --> 00:48:18,976
来生成所有的叙事数据

1371
00:48:24,216 --> 00:48:27,106
这个 RECORDER:: 规则

1372
00:48:27,106 --> 00:48:28,546
查看所有 started-download 事实

1373
00:48:28,726 --> 00:48:29,986
并捕获它们

1374
00:48:30,616 --> 00:48:32,136
我们捕获 time caller-address

1375
00:48:32,136 --> 00:48:33,696
以及 image-name

1376
00:48:34,796 --> 00:48:36,936
如果这里是 true

1377
00:48:37,606 --> 00:48:39,176
有另一个具有相同 caller-address 的

1378
00:48:39,216 --> 00:48:40,996
started-download 事实

1379
00:48:40,996 --> 00:48:42,786
你就可以注意到

1380
00:48:42,786 --> 00:48:44,646
这里引用的变量是相同的

1381
00:48:45,376 --> 00:48:48,616
并且在第一个事实之前发生

1382
00:48:49,606 --> 00:48:51,136
我们注意到

1383
00:48:51,136 --> 00:48:52,326
存在一些反向模式

1384
00:48:52,326 --> 00:48:53,616
而且在请求中存在重叠

1385
00:48:54,716 --> 00:48:56,086
我们可以检查

1386
00:48:56,086 --> 00:48:57,346
是否可以访问

1387
00:48:57,346 --> 00:49:01,386
downloader-narrative Schema

1388
00:48:57,346 --> 00:49:01,386
downloader-narrative Schema

1389
00:49:01,386 --> 00:49:05,766
在其中创建新的行

1390
00:49:05,856 --> 00:49:08,976
将列的时间设置为第一个事实的时间

1391
00:49:08,976 --> 00:49:10,266
并设置列的描述

1392
00:49:11,036 --> 00:49:13,796
你需要输出

1393
00:49:13,796 --> 00:49:15,486
关于这个问题的一些信息

1394
00:49:15,846 --> 00:49:19,216
以便之后有人可以调试它

1395
00:49:19,456 --> 00:49:21,916
现在我可以在 App 上运行 Instruments 

1396
00:49:22,636 --> 00:49:24,956
让我们再次运行它

1397
00:49:32,216 --> 00:49:38,156
再次选择《Trailblazer》网络模板并记录

1398
00:49:38,936 --> 00:49:41,766
我将尝试执行一些

1399
00:49:41,766 --> 00:49:44,976
快速滚动并查看我的叙事表

1400
00:49:49,636 --> 00:49:51,836
你可以看到

1401
00:49:51,886 --> 00:49:53,406
叙事表包含大量

1402
00:49:53,406 --> 00:49:55,066
正在输出的诊断消息

1403
00:49:56,026 --> 00:49:57,706
我们可以看到

1404
00:49:57,706 --> 00:49:59,126
存在一些问题

1405
00:49:59,126 --> 00:49:59,866
之后再研究它们

1406
00:50:00,876 --> 00:50:03,086
你可以看到

1407
00:50:03,176 --> 00:50:04,186
叙事表是可互动的细节视图

1408
00:50:04,876 --> 00:50:06,526
例如 你可以检查

1409
00:50:06,526 --> 00:50:07,746
所有传入的参数

1410
00:50:07,876 --> 00:50:09,066
并进行筛选

1411
00:50:09,496 --> 00:50:11,586
我们可以添加这个调用者地址

1412
00:50:11,586 --> 00:50:13,826
成为一个细节过滤器

1413
00:50:13,826 --> 00:50:15,476
并拥有这个细节过滤器

1414
00:50:17,476 --> 00:50:19,386
现在 让我们请回 Chad

1415
00:50:19,386 --> 00:50:21,146
他将告诉你更多

1416
00:50:21,216 --> 00:50:23,446
关于开发 Instruments 的最佳实践经验

1417
00:50:24,516 --> 00:50:29,896
[ 掌声 ]

1418
00:50:30,396 --> 00:50:30,646
>> 好的

1419
00:50:30,646 --> 00:50:31,326
谢谢 Kacper

1420
00:50:32,076 --> 00:50:34,616
我们已经看到如何在 Instruments 中

1421
00:50:34,616 --> 00:50:37,016
创建一些基本的专家系统

1422
00:50:37,106 --> 00:50:39,656
好的 我们来谈谈

1423
00:50:39,826 --> 00:50:42,316
在这个过程中

1424
00:50:42,316 --> 00:50:43,156
我们学到的一些最佳实践经验

1425
00:50:43,416 --> 00:50:46,796
第一个是

1426
00:50:46,796 --> 00:50:47,986
编写多个 Instrument

1427
00:50:48,236 --> 00:50:49,566
我的意思并不是

1428
00:50:49,566 --> 00:50:50,286
练习编写 Instrument

1429
00:50:50,776 --> 00:50:52,146
而是 如果你

1430
00:50:52,146 --> 00:50:52,926
已经拥有了一个 Instrument

1431
00:50:52,926 --> 00:50:54,096
并且想给它添加一些特性

1432
00:50:54,396 --> 00:50:55,486
有时候 给你的 Instrument

1433
00:50:55,486 --> 00:50:56,826
添加额外的图形或细节

1434
00:50:56,826 --> 00:50:57,826
真的很容易

1435
00:50:57,826 --> 00:50:59,346
但是你应该

1436
00:50:59,346 --> 00:51:00,306
真正地思考

1437
00:50:59,346 --> 00:51:00,306
真正地思考

1438
00:51:00,306 --> 00:51:01,876
这样的话 它还可以成为自身的 Instrument 吗

1439
00:51:02,226 --> 00:51:03,216
这样想的原因是

1440
00:51:03,216 --> 00:51:05,366
如果你创建更细粒度的 Instrument

1441
00:51:05,726 --> 00:51:07,326
你会给这个 Instrument 的用户

1442
00:51:07,326 --> 00:51:08,766
更多的选择

1443
00:51:09,256 --> 00:51:10,686
他们可以从库中

1444
00:51:10,686 --> 00:51:11,716
拖出他们想要的 Instrument

1445
00:51:11,716 --> 00:51:13,156
这将最小化

1446
00:51:13,156 --> 00:51:15,496
对目标的记录影响

1447
00:51:15,876 --> 00:51:17,306
如果你把注意力集中在一个

1448
00:51:17,306 --> 00:51:18,546
有很多功能的 Instrument 上

1449
00:51:18,546 --> 00:51:19,416
那对用户来说 将是一个全盘接受

1450
00:51:19,416 --> 00:51:20,026
与被迫放弃之间的选择

1451
00:51:20,986 --> 00:51:24,616
如果你想创建

1452
00:51:24,616 --> 00:51:26,066
针对某个问题

1453
00:51:26,636 --> 00:51:27,476
的一组 Instrument

1454
00:51:27,476 --> 00:51:29,666
你一定想要看到

1455
00:51:29,666 --> 00:51:31,366
所有这些 Instrument 同时被使用

1456
00:51:31,366 --> 00:51:33,616
那么你所能做的就是

1457
00:51:33,616 --> 00:51:34,976
像我们创建网络模板那样

1458
00:51:35,146 --> 00:51:36,156
创建自己的自定义模板

1459
00:51:36,696 --> 00:51:37,896
所以你要做的应该是

1460
00:51:37,896 --> 00:51:39,486
创建一个文档

1461
00:51:39,486 --> 00:51:42,126
以你想要的方式拖拽 Instrument 配置它们

1462
00:51:42,126 --> 00:51:44,116
进入文件

1463
00:51:44,116 --> 00:51:45,316
然后保存为模板

1464
00:51:45,706 --> 00:51:46,696
然后你就可以在你的包中

1465
00:51:46,696 --> 00:51:48,656
使用那个模板

1466
00:51:48,836 --> 00:51:50,666
同时使用 Kacper

1467
00:51:50,666 --> 00:51:52,496
在我们的网络模板中添加的元素

1468
00:51:53,226 --> 00:51:54,606
使用多种 Instrument 编写

1469
00:51:54,606 --> 00:51:56,486
是使用工具更好的方式

1470
00:51:58,046 --> 00:52:00,336
第二 即时模式很难

1471
00:51:58,046 --> 00:52:00,336
第二 即时模式很难

1472
00:52:01,156 --> 00:52:03,256
即时模式指的是

1473
00:52:03,256 --> 00:52:04,616
Instruments 的记录模式

1474
00:52:04,916 --> 00:52:07,016
它可以在接近实时的时候

1475
00:52:07,016 --> 00:52:08,916
将数据可视化

1476
00:52:08,916 --> 00:52:12,766
有两个原因导致它很难

1477
00:52:12,856 --> 00:52:14,246
第一个原因是

1478
00:52:14,246 --> 00:52:16,006
它需要一些额外的支持

1479
00:52:16,006 --> 00:52:17,176
尽管今天我们很想向你们介绍这点

1480
00:52:17,176 --> 00:52:18,436
但是很遗憾没有办法

1481
00:52:18,436 --> 00:52:19,546
时间有限

1482
00:52:19,956 --> 00:52:20,726
所以我们将会

1483
00:52:20,726 --> 00:52:21,936
为此编写文档

1484
00:52:22,426 --> 00:52:24,156
第二个原因

1485
00:52:24,156 --> 00:52:26,456
也是更重要的原因

1486
00:52:26,456 --> 00:52:29,296
就是区间数据

1487
00:52:29,296 --> 00:52:31,236
区间不能被输入到

1488
00:52:31,236 --> 00:52:32,766
分析核心的表中

1489
00:52:32,766 --> 00:52:34,406
除非它们被关闭

1490
00:52:34,406 --> 00:52:35,316
这意味着这时我们已经

1491
00:52:35,316 --> 00:52:36,346
看到了开始和结束

1492
00:52:36,496 --> 00:52:37,576
所以当你查看

1493
00:52:37,576 --> 00:52:39,386
现场记录的时候

1494
00:52:39,386 --> 00:52:40,696
你会发现一堆所谓的“开区间”

1495
00:52:40,886 --> 00:52:42,216
如果你的建模器

1496
00:52:42,216 --> 00:52:43,506
需要它们作为输入

1497
00:52:43,586 --> 00:52:45,576
这是完全可行的

1498
00:52:45,576 --> 00:52:46,956
而且你会注意到

1499
00:52:46,956 --> 00:52:48,936
如果上游有一个开区间

1500
00:52:48,936 --> 00:52:50,426
那么下游的所有建模器时钟

1501
00:52:50,426 --> 00:52:52,266
都必须停止

1502
00:52:52,266 --> 00:52:53,716
直到那个区间关闭

1503
00:52:53,716 --> 00:52:55,186
因为建模器的视图

1504
00:52:55,186 --> 00:52:56,986
都是按时间排序的

1505
00:52:57,116 --> 00:52:58,796
除非所有的区间

1506
00:52:58,796 --> 00:53:00,196
都被关闭

1507
00:52:58,796 --> 00:53:00,196
都被关闭

1508
00:53:00,196 --> 00:53:01,516
否则无法把时钟向前移动

1509
00:53:02,076 --> 00:53:03,086
所以如果你有一些

1510
00:53:03,086 --> 00:53:04,856
占用时间很长的区间

1511
00:53:04,856 --> 00:53:06,636
你会注意到

1512
00:53:06,636 --> 00:53:08,276
建模器的输出似乎停止了

1513
00:53:08,986 --> 00:53:11,336
当用户点击

1514
00:53:11,626 --> 00:53:13,506
停止记录按钮

1515
00:53:13,556 --> 00:53:14,516
所有的开启的区间都被关闭时

1516
00:53:14,516 --> 00:53:15,836
所有的进程才将正常

1517
00:53:15,976 --> 00:53:17,136
数据也才会涌入

1518
00:53:17,606 --> 00:53:19,036
但这种用户体验并不好

1519
00:53:19,416 --> 00:53:21,676
如果停止录制

1520
00:53:21,676 --> 00:53:22,396
你将有两种选择

1521
00:53:22,396 --> 00:53:24,686
第一个是将 Instruments 退出

1522
00:53:24,686 --> 00:53:26,066
即时模式支持

1523
00:53:26,066 --> 00:53:27,376
为此你可以给你的 Instrument

1524
00:53:27,376 --> 00:53:28,846
添加一个限制元素

1525
00:53:28,916 --> 00:53:31,396
第二个是不再将区间数据

1526
00:53:31,396 --> 00:53:34,096
作为建模器的输入

1527
00:53:34,096 --> 00:53:35,746
就像我们在演示中

1528
00:53:35,746 --> 00:53:38,136
为我们的专家系统

1529
00:53:38,136 --> 00:53:39,856
所做的那样

1530
00:53:39,856 --> 00:53:41,316
我们实际上使用的是

1531
00:53:41,316 --> 00:53:42,746
os-signpost-point 事件

1532
00:53:42,746 --> 00:53:44,176
而不是 os-signpost-interval

1533
00:53:45,316 --> 00:53:47,156
我知道我们让它看起来简单

1534
00:53:47,326 --> 00:53:49,086
但是即时模式实现起来

1535
00:53:49,086 --> 00:53:50,046
确实有点棘手

1536
00:53:50,436 --> 00:53:55,056
第三 非常重要的一点

1537
00:53:55,056 --> 00:53:56,256
如果你要创建的 Instrument

1538
00:53:56,256 --> 00:53:57,046
针对的是

1539
00:53:57,046 --> 00:53:59,156
大量的输入数据

1540
00:53:59,156 --> 00:54:00,646
那么最后 5 秒

1541
00:53:59,156 --> 00:54:00,646
那么最后 5 秒

1542
00:54:00,646 --> 00:54:03,466
记录模式

1543
00:54:03,466 --> 00:54:04,066
是最有效的

1544
00:54:04,346 --> 00:54:05,816
你可以在跟踪文档的

1545
00:54:05,816 --> 00:54:07,256
记录选项中进行切换

1546
00:54:07,256 --> 00:54:08,886
之后你将看到

1547
00:54:08,886 --> 00:54:09,776
你可以在即时 延迟

1548
00:54:09,776 --> 00:54:11,256
和最后 n 秒模式之间

1549
00:54:11,256 --> 00:54:12,676
进行选择

1550
00:54:13,246 --> 00:54:14,486
更加有效的原因是

1551
00:54:14,486 --> 00:54:16,476
它允许记录技术

1552
00:54:16,476 --> 00:54:18,016
使用缓冲

1553
00:54:18,296 --> 00:54:19,666
来提高性能

1554
00:54:19,716 --> 00:54:20,906
这样它就不会一直尝试

1555
00:54:20,906 --> 00:54:22,976
实时向 Instruments 提供数据

1556
00:54:23,376 --> 00:54:24,586
这将产生深远的影响

1557
00:54:24,586 --> 00:54:26,876
它会对 signpost 数据

1558
00:54:26,876 --> 00:54:28,286
产生巨大的影响

1559
00:54:28,286 --> 00:54:29,856
在最后 5 秒模式下

1560
00:54:30,096 --> 00:54:31,756
速度可以提升 10 倍

1561
00:54:32,246 --> 00:54:33,326
当然 为此的权衡是

1562
00:54:33,466 --> 00:54:34,796
你只能看到

1563
00:54:34,796 --> 00:54:37,136
最后 5 秒的数据

1564
00:54:37,296 --> 00:54:39,056
但是对于产生大量

1565
00:54:39,056 --> 00:54:40,736
数据的 Instrument 来说

1566
00:54:40,736 --> 00:54:41,276
这通常是件好事

1567
00:54:41,446 --> 00:54:43,016
这使得它成为

1568
00:54:43,016 --> 00:54:45,346
系统跟踪和 Metal 系统跟踪

1569
00:54:45,346 --> 00:54:46,916
以及游戏性能模板的通用模式

1570
00:54:47,176 --> 00:54:50,066
如果你的目标是这类 App 

1571
00:54:50,066 --> 00:54:51,546
我也会建议

1572
00:54:51,546 --> 00:54:53,136
你的 Instrument 不要支持即时模式

1573
00:54:53,476 --> 00:54:54,506
这样你的用户体验

1574
00:54:54,506 --> 00:54:56,096
就不会很糟糕

1575
00:54:56,096 --> 00:54:58,086
Instruments 在获取数据时

1576
00:54:58,086 --> 00:54:59,236
也不会出现延后

1577
00:54:59,236 --> 00:55:00,746
你在区间中也不会遇到类似的问题

1578
00:54:59,236 --> 00:55:00,746
你在区间中也不会遇到类似的问题

1579
00:55:02,926 --> 00:55:04,326
我们的讨论会差不多结束了

1580
00:55:04,896 --> 00:55:08,026
我们今天谈论很多

1581
00:55:08,026 --> 00:55:09,116
关于创建 Instrument 特性的内容

1582
00:55:09,116 --> 00:55:10,456
我们真的非常兴奋

1583
00:55:10,456 --> 00:55:11,386
因为我们能够

1584
00:55:11,386 --> 00:55:12,306
在今年向你们展示这一切

1585
00:55:12,686 --> 00:55:14,636
我们迫不及待地想知道

1586
00:55:14,636 --> 00:55:15,746
你们能通过 Instruments 创造什么样的成果

1587
00:55:16,146 --> 00:55:17,906
如果你想和我们

1588
00:55:17,906 --> 00:55:18,926
谈谈自定义 Instrument

1589
00:55:18,926 --> 00:55:21,176
我们将在今天下午 3 点

1590
00:55:21,566 --> 00:55:23,986
8 号实验室等待各位

1591
00:55:23,986 --> 00:55:25,916
另外 405 号讨论会详细介绍了

1592
00:55:25,916 --> 00:55:27,256
如何使用 os_signpost API

1593
00:55:27,256 --> 00:55:29,156
你可以通过它将数据输入 Instruments 

1594
00:55:29,856 --> 00:55:30,976
请享受接下来的讨论会

1595
00:55:31,516 --> 00:55:34,500
[ 掌声 ]


