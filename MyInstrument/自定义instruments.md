

我们将讨论如何在 Instruments 10 中创建自定义 Instrument以及三个入门、中级和进阶部分
## 为什么要创建自定义 Instrument
Instruments 已经集成了很多非常强大的工具，例如这里我们有系统跟踪
你可以看到 App如何与调度器，和虚拟内存交互，还有今年新推出的游戏性能模板它结合了**系统跟踪**和 **Metal**，**系统跟踪**来帮助你发现 App 中的故障和丢失的帧。
在 App 的网络部分有**网络连接 Instrument**，它可以显示进出 App 的TCP/IP 流量；**时间分析器**帮助你查看App在何处花费时间。
无论是网络层、游戏引擎还是其他部分，当你想要了解正在编辑的代码是如何工作的，这些都是非常有用的，如果你知道这些 IP 地址是什么意思，知道不同的函数是什么意思，以及时间分析器的调用堆栈，它会让事情变得更简单。
如果有人打算分析你的 App，但他们不熟悉其中的代码，只是想知道App 是否在网络层上花费了大量的时间，那该怎么办呢？

自定义 Instrument 的一个很好的用途就是尝试以一种使原本无法理解代码的人能够理解和欣赏代码的方式讲述你的某一层或 App正在做什么。

在进阶部分中我们将向你展示如何利用在 Instruments内部构建的专家系统技术，以便你可以创建一个即使你不亲力亲为也能够查找错误模式，并在代码中发现反面模式的 Instrument。

### 回顾一下Instruments 的结构
使上述功能成为可能的架构，要做到这一点，我们必须从这里开始，回到原始版本，起初的 Instruments 的工作原理和今天的差不多同样有一个库，仍然可以拖出 Instrument，并将它们放入跟踪文档中，然后按下记录按钮，多个性能工具就可以同时运行。
那时和现在的 Instruments 之间的区别是，当时的 Instruments 基础结构并无法帮助我们快速编写 Instrument。在当时这样还好，因为我们已经继承了一些我们已有的素材和性能工具，它们都有自己的记录技术和分析逻辑，我们所要做的就是建立一个自定义的存储机制，来获取跟踪中的数据，以及一个自定义的 UI 来帮助它与 App 的其他部分集成。
随着时间的推移hInstruments 的维护成本和模型的维护成本都上升了，原因就是每次我们想要添加新特性时，我们必须修改 7 个自定义 UI和 7 个自定义存储机制。但这不是我们想让你们学习的处理方式，我们不想让你们承担这种维护成本，所以在我们讨论定制 Instrument 的特性之前，我们首先需要解决这个问题。
在新版本的 Instruments 中我们没有自定义 UI和自定义存储机制，而是有两个标准化的组件达到最佳实践。

### 编写我们自己的 Instrument时，能学到的东西, 达到最佳实践
在新版本的 Instruments 中我们没有自定义 UI和自定义存储机制，而是有两个标准化的组件：
1. **标准化的组件**
它们是 “Standard UI（标准 UI）”和“Analysis Core（分析核心）”，**标准 UI** 实现了新版 Instruments 的整个用户界面，它与分析核心紧密相连。**分析核心**你可以将其视为数据库和专家系统的结合，这两种都针对时间序列数据进行了优化。
使得它们成为构建 Instrument 的重要基础，当你使用新型架构，构建一个 Instrument 时，实际上你所做的是创建标准 UI和分析核心的自定义配置。
如果你看一下我一开始展示的那些强大的 Instrument的屏幕快照，有系统跟踪、游戏性能模板、网络连接模板以及时间分析器，所有这些文档中的所有 Instrument都是完全基于标准 UI和分析核心生成的。所以你也同样可以做，它们能做的事情。

在 Xcode 10 和 Instruments 10 中，我们提供了相同的工具 来构建你的 Instrument，Xcode 集成的 Instrument和你生成的 Instrument 之间的唯一区别就是谁生成了它。
你的 Instrument 会显示在我们的库中，你可以看到顶部的活动监视器就像这样。你可以将你的 Instrument 拖放到跟踪文档中并进行记录，然后Instruments 会将用数据填充分析核心，标准 UI 将创建图形和表格视图。
Instruments 有两种显示数据的方式：在顶部有一个图形化的视图，我们称之为轨道视图，
### 轨道视图
一个 Instrument 可以根据需要定义多个轨道。在定义 Instrument 的图之间进行选择，在 Instrument 图标上有一个小控件你可以把它从 “CPU” 改为 “Network（网络）”，每个图都被允许定义一定数量的轨道，这里我们定义了 3 个轨道，并绘制了 3 种不同类型的CPU 利用情况。
### 细节视图
这里的每一个轨道都被绑定到分析核心中的不同的表上或者它可以被绑定到同一个表上，但是你看到的是这个表中的另一列，这个 Instrument 的另一部分就在下方它同样也很重要它叫做细节视图，在这里你可以看到事件列表以及数据的任何类型的聚合和总结。就像这些图一样，你可以为你的 Instrument定义一些细节，你也可以通过点按跳转栏的这个部分，选择你定义的细节标题，来选择哪个细节是活跃的。就像图形视图中的轨道一样，所有的细节都被绑定到分析核心的一个表上。这就是它们接收数据的地方
，记录开始，表格被填入，UI 就会做出反应，不需要你执行任何特殊代码，从标准 UI 的角度来看，分析核心中的所有内容，似乎都是一个表格
### 表格
表格是行的集合，它们有一个由表格 Schema 定义的结构，所以它和数据库 App 非常相似，这个 Schema 定义了列 列的名称，以及列的类型。分析核心使用了一个非常丰富的类型系统叫做工程类型，它告诉我们如何存储数据以及如何在标准 UI 中可视化和分析数据。
除此之外，当 Schema 描述表的结构时，你还可以使用 Key/value 这对属性来描述内容，这能帮助我们描述表中的内容。
你可以将 Schema视为 Objective-C 或 Swift 中的一个类，而行则类似于实例，就像 Objective-C 中的类名是单数的一样。你的 Schema 的名称也必须是单数的，比如 NSString而不是 NSStrings。当我们讲到进阶部分的时候，这一点会更为重要。
### 表格一个例子Tick
Schema 的一个例子是 Tick，它是 Instruments内部的一种 Schema，用于创建合成时钟节拍表。
稍后我们将在建模器中使用它进行统计计算。
Tick Schema 很简单，它定义一个**time**列，time 使用的工程类型是**sample-time**； 还定义了一个可以附加到表格实例中的可选属性**frequency**。
如果你为 Tick Schema创建一个频率为 10 的表格、那么数据的提供者就会知道它需要每秒填充 10 个时间戳，这样你就可以表达你想要填入表的内容。

## 上机实战
现在假设我认为我们有足够的信息，来开始入门部分，我们将展示如何在 Xcode 中创建你自己的 Instruments 包项目，还将向你展示 如何创建你的第一个 Instrument，来绘制这些 Tick，并在细节视图中 显示这些 Tick。
1. 如何开始创建和运行第一个自定义 Instrument 
你们将会使用 Tick Schema 表格，在频率恒定的节拍中，制作一个 Instrument。
* 如何描述你们的包
* 如何使用 Xcode 对其进行迭代
* 如何在 Instruments 中进行测试

### 在 Xcode 中创建新的 Instruments 包项目
点击 “New Xcode Project”，选择 “macOS” 作为平台，并点击 “Instruments Package”你需要填写文件名称，这将成为这个 Instrument 包的默认名称，我们就命名为 “Ticks” 吧；
点击 “Next（下一步）”和“Create（创建）”完成创建，生成了带有包 Target 的项目和对包定义的一个配置文件。
#### xml包文件
包是基于 XML 语法描述的
首先每个包最前面有**标识符**、**标题**和**所有者**，当有人试图安装你的包时，这些栏将是可见的。
1. 定义Schema和可选的建模器
在这里使用预定义的 **Tick Schema**，要从基础包中导入 **Tick Schema**，你只需指定`import-schema`元素和 Schema 的名称 “tick”.
现在它可以被我们的 Instrument 使用了.
2. 高级配置
Xcode 中提供一些代码片段辅助开发者定义更复杂的元素，要使用它们只需写入元素名称，比如 “instrument” 然后按回车。
你需要填写你的 Instrument 的唯一标识符以及稍后出现在Instrument 库中的一些属性，这里是 “Instrument drawing ticks every 10ms”。
3. 创建**tick-table**表格
在这个 Instrument 的定义中创建一个唯一标识符为**tick-table**的表格，当这个 Instrument 从库中拖到跟踪文档时，这个表格会被实例化。在 `<schema-ref>` 中我们需要引用以前导入的 Schema**tick**。
使用 `graph` 元素定义在轨道视图和细节视图中显示的`title`/`轨道`名为**Ticks** 。再通过标识符来关联表格 **tick-table**。
使用 `plot` 元素为图指定绘制。在最基本的形式中，它只需要你传递包含要绘制的值的列的助记符。
使用 `list` 元素为图指定绘制,例如将 **time**所有的时间戳都能在表格中显示出来
将会出现在 Instrument 中的列表填写 title 元素，“table-ref” 就像之前的 lane 元素一样，以及我们想要看到的 column
### 使用
现在我们的包已经准备好，使用“Xcode Scheme Run” 在 Instruments 中构建并运行。
在生成 Instruments 包时，你拥有完整的 IDE 支持，你可以看到它在运行因为这个新的 Instrument 副本出现了你可以通过不同的图标识别特殊的副本，它仅为这个运行会话加载你的包，它允许你更容易地对包进行迭代。
了确认你的包已经加载，我们可以在新建包管理的 UI 中检查它，你可以在 “Instruments”-“Preferences（偏好设置）”-“Packages（包）”标签页中找到它。
你可以在这里看到我们新创建的包以及调试的下标，这意味着它已经被临时加载，你也可以在这里看到所有的系统包，你可以通过使用副标题。使用并链接它们，在这里 我们的 Ticks 包里包含了Ticks Instrument 现在让我们用空白模板测试它
我将把 Target 切换到我的 MacBook，然后在 Instruments 库中搜索我的 Instrument，我将填入 “Ticks”然后它将显示在这里，包含从包定义中填充的所有属性。
让我们将它拖放到跟踪中并记录一秒钟，你可以看到底部的面板是以每 10 毫秒生成的数据，进行传递的，细节和图形是相互协调的。
当我点击行时，你可以看到检查线在这里移动，我还可以通过 Option 点按并拖动来而放大一个图，在这里你可以看到Ticks 确实被画出来了。
这样你就可以创建第一个 Instrument 包。

## 高级
我们已经知道了如何创建一个非常基本的 Instrument，也了解了如何开始在 Xcode 中创建你的第一个项目。
现在让我们来谈谈不同类型的图，不同类型的细节，以及如何利用真实数据进行操作。
### 图形轨道
使用  `plot` 元素定义一个图形和轨道,`plot` 元素可以指示标准 UI 获取表的全部内容,并尝试在特定的轨道中绘制它.
plot 元素通过查看Schema 和获取值的目标列,来决定如何绘制这个内容以及如何处理图形.
如果是一个区间 Schema,这意味着它有一个时间点和一个持续时间.如果是一个点 Schema,这意味着它只是一个时间戳,我们需要用不同的方式处理.
如果目标列有一个长度,这意味着可以通过它画一个条形图,就像这样
另一种选择是生命周期轨道,它仍然是一个区间 Schema,但是我们针对的是一个状态列,而状态本身并没有长度,所以在这里画条形图是没有意义的.标准 UI 会自动选择状态风格的处理方法,包括用圆角矩形样式的标签绘制这些区间,这样你就可以把它与平面条形图区分开来.
标准 UI 能够为你选择这些处理的功能是非常重要的.因为这可以保持 Instruments UI 的一致性,如果你定义一个状态图的同时,我们也定义一个状态图,标准 UI 就会强制它们看起来一样.
这样 Instruments 用户就可以更容易在 Instrument 之间进行切换,
#### Plot 模板
如果你想 基于数据的内容动态地创建图形或轨道数目,动态地创建图形或轨道数目,你可以定义所谓的 “Plot Template”.
Plot 模板的定义与 Plot 非常类似,除了其中有一个额外的元素允许你选择表中的一列,它将为该列中的每个唯一值创建单独的行
如果你正在寻找活动的峰值或周期我们有所谓的直方图,你所要做的就是在不同的点或区间相交时,打破超过某个特定大小的存储器中的时间轴.
假设 100 毫秒然后使用像 count() sum()min() 或 max() 这样的函数来提升这些存储器的大小,这是一种寻找活动峰值的好方法
例如 在系统跟踪中,我们在环境切换或虚拟内存中寻找活动峰值.

### 细节列表
细节列表是**表格**、**分析核心**以及 UI 中表视图之间的非常简单的映射，还有 “Aggregation（聚合）”。
当你想要去除时间分量来概览你的数据，而且想要在表格中应用一些统计数据的时候，聚合是很适合的选择。
当我们定义一个聚合，我们需要注意在这里**列**是函数，你可以使用sum() average() count()以及其他的一些统计函数来帮助你创建。
你想要创建的聚合视图，聚合的好处在于你也可以定义一个层级结构。
这里我们在虚拟内存操作结构中定义了一个进程线程，我们可以看到它被分解为进程，然后是进程中的每个线程，然后是这个线程中的。这个进程中的每个类型的操作，所以聚合是一种很好、很强大的方式来总结很多数据
#### Call Tree（调用树）
另一种类型的聚合称为 “Call Tree（调用树）”当你有一个列是回溯而且另一个列是权重的时候，调用树就会很有用处，你可以使用调用树创建加权回溯或加权调用的树视图,就像在时间分析器中看到的那样。
#### Narrative（叙事）
另一种样式叫做 “Narrative（叙事）”当你想要传达只有技术语言的信息，比如专家系统的输出以及和叙事工程类型紧密相连的信息时，叙事是常用的选择
#### Time Slice（时间片）
最后一种细节类型叫做 “Time Slice（时间片）”时间片看起来很像一个列表，但是其中的内容被过滤，只包含与图形中蓝色线相交的区间，这条蓝色线叫做检查线，当你把检查线移到图形上时，列表的内容将被过滤从而与检查线相交的部分匹配。

### 统计原理
所有这些 UI 都与分析核心中的表格绑定，当你开始记录时，数据进入 Instruments App，并填入分析核心中。
让我们详细谈谈这个过程是如何进行的，
#### 第一步记录
在开始记录之前的第一步，**分析核心**将提取在其中创建的表格，它将映射表格，并在核心中为表分配存储。如果一个表有相同的 Schema 和相同的属性，那么根据定义，它就是相同的数据，所以对于每个存储它会被映射到相同的存储中。
#### 第二步定位提供者
第二步就是尝试为数据找到一个提供者，有时我们可以从 Target 中通过数据流直接记录数据，有时我们则必须使用建模器来合成数据。建模器可以请求自己的输入，这些输入可以是其他建模器的输出或者直接从数据流中记录，我们就是这样合成。
我们本来不知道如何直接记录的其余数据的，现在我们已经得到了，**分析核心**中所有存储的数据源，也就是所谓的绑定方案。
#### 第三步优化绑定方案 
在这里 你可以看到 Instruments 将自己的绑定方案可视化，我们称之为线程叙事。关于绑定方案的下一部分是它是 “Trace-wide（广跟踪）”的。当你将 Instrument 拖放到跟踪中时，Instruments 将计算尽可能最好的记录方案，以尽量减少对 Target 的记录影响。
当你创建自己的表格或表实例时，你必须给它们一个 Schema，Instruments 已经定义了超过 100 种 Schema，所有这些 Schema都可以使用。并存在于在包管理的 UI 中所看到的包里面，你只需将 Schema 导入到自己的包中。
如果该 Schema 包含在一个不是基础包的包中，你需要在 Xcode 中的构建设置里面，将包设置为“Linked Instruments Packages”，这样我们就可以在生成时，找到你涉及的额外的包，并做一些类型检查，因为所有这些 Schema，都是在其他包中定义的，当你开始记录时，所有具有这些 Schema 的表格，都会被填充，因为要么它们定义了建模器，要么我们知道如何从数据流中记录它们，这些都是你的 Instrument 的出色的构件。
#### 建模器
但它们更是编写建模器的优秀输入，现在你已经可以编写一个建模器，或者在你的 Instrument 包中用 modeler 元素定义一个建模器。你还可以为该建模器创建一个自定义输出 Schema，你可以使用 point-schema只对一个时间点，或者如果你使用 interval-schema建模器可以定义一个时间点和一个区间，这就告诉了绑定方案如何填充数据流图的其余部分，这样你的建模器将融合到绑定方案中。
建模器实际上是微型专家系统。它们是用 CLIPS 语言编写的，这意味着它们非常强大同时非常先进

关于如何创建建模器的细节，我们将留在进阶部分讨论，然而 能够定义自己的 Schema是非常重要的
#### os_signpost日志句柄
我们今年有了一个新的 **os_signpost API**它是把数据导入 Instruments 的绝佳方式，我们为它创造了一条捷径，在你的包中 你可以定义所谓的`os-signpost-interval-schema`,它既可以定义 Schema,也可以为我们提供足够的指令以便能够代替你生成一个建模器.
在那里你可以捕获在 os_signpost 调用的元数据中记录的数据,你可以使用捕获的元数据和表达式来定义如何填充你的 Schema 的列.
我们来看一个非常简单的例子
假设我们要做 JSON 解码，我们有一个 `os_signpost`标记了解码 Activity 的开始和解码 Activity 的结束。在开始时,我们还需捕获一些元数据以指示我们将要解析的JSON 对象的大小，在你的 Instrument 包定义中你可以创建一个**os-signpost-interval-schema**，并在这里定义你的 Schema 名称，你可以选择要记录的 signpost，包括 signpost 名称，然后在这里可以使用语法，从起始元数据消息中捕获不同的元数据片段。
这里我们将使用这个捕获的值我们将用它作为表达式来教我们如何填充我们刚才定义的数据大小的列

在 405 号讨论会中 即 “Measuring Performance Using Logging”我演示了《Trailblazer》App 还展示了一个 Instrument，你们可以根据这个 Instrument里面的 signpost 来进行编写。
现在我们对如何编写自定义 Instrument 有了更多的了解。
